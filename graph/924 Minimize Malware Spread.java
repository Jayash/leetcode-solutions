class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        if(initial.length == 0) return -1;
        
        int[] uf = new int[graph.length];
        
        Arrays.fill(uf, -1);
        
        for(int i=0; i< graph.length; i++) {
            for(int j= i+1; j<graph[0].length; j++) {
                if(graph[i][j] == 1) {
                    int parentForI = find(i, uf);
                    int parentForJ = find(j, uf);
                    if(parentForI != parentForJ)
                        union(parentForI, parentForJ, uf);
                }
            }
        }
        
        
        
        int min = Integer.MAX_VALUE;
        int minNode = 0;
        
        for(int i: initial) {
            Set<Integer> set = new HashSet<>();
            int maxSpread = 0;
            for(int j=0; j< initial.length; j++) {
                if(i != initial[j]) {
                    int parent = find(initial[j], uf);
                    if(!set.contains(parent)) {
                        maxSpread += Math.abs(uf[parent]);
                        set.add(parent);
                    }
                }
            }

            if(maxSpread < min) {
                min = maxSpread;
                minNode = i;
            } else if(maxSpread == min) {
                if(i < minNode) minNode = i;
            }
            
        }
        
        return minNode;
    }
    
    public int find(int node, int[] uf) {
        
        while(uf[node] >= 0) {
            node = uf[node];
        }
        
        return node;
    }
    
    public void union(int i, int j, int[] uf) {
        if(Math.abs(uf[i]) >= Math.abs(uf[j])) {
            uf[i] = -1 * (Math.abs(uf[i]) + Math.abs(uf[j]));
            uf[j] = i;
        } else {
            uf[j] = -1 * (Math.abs(uf[i]) + Math.abs(uf[j]));
            uf[i] = j;  
        }
    }
}
